// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --auto --filename ./crd-catalog/kubeedge/kubeedge/apps.kubeedge.io/v1alpha1/edgeapplications.yaml
// kopium version: 0.16.1

use kube::CustomResource;
use schemars::JsonSchema;
use serde::{Serialize, Deserialize};

/// Spec represents the desired behavior of EdgeApplication.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "apps.kubeedge.io", version = "v1alpha1", kind = "EdgeApplication", plural = "edgeapplications")]
#[kube(namespaced)]
#[kube(status = "EdgeApplicationStatus")]
pub struct EdgeApplicationSpec {
    /// WorkloadScope represents which node groups the workload will be deployed in.
    #[serde(rename = "workloadScope")]
    pub workload_scope: EdgeApplicationWorkloadScope,
    /// WorkloadTemplate contains original templates of resources to be deployed as an EdgeApplication.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadTemplate")]
    pub workload_template: Option<EdgeApplicationWorkloadTemplate>,
}

/// WorkloadScope represents which node groups the workload will be deployed in.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct EdgeApplicationWorkloadScope {
    /// TargetNodeGroups represents the target node groups of workload to be deployed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetNodeGroups")]
    pub target_node_groups: Option<Vec<EdgeApplicationWorkloadScopeTargetNodeGroups>>,
}

/// TargetNodeGroup represents the target node group of workload to be deployed, including override rules to apply for this node group.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct EdgeApplicationWorkloadScopeTargetNodeGroups {
    /// Name represents the name of target node group
    pub name: String,
    /// Overriders represents the override rules that would apply on workload.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overriders: Option<EdgeApplicationWorkloadScopeTargetNodeGroupsOverriders>,
}

/// Overriders represents the override rules that would apply on workload.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct EdgeApplicationWorkloadScopeTargetNodeGroupsOverriders {
    /// ImageOverriders represents the rules dedicated to handling image overrides.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageOverriders")]
    pub image_overriders: Option<Vec<EdgeApplicationWorkloadScopeTargetNodeGroupsOverridersImageOverriders>>,
    /// Replicas will override the replicas field of deployment
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i64>,
}

/// ImageOverrider represents the rules dedicated to handling image overrides.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct EdgeApplicationWorkloadScopeTargetNodeGroupsOverridersImageOverriders {
    /// Component is part of image name. Basically we presume an image can be made of '[registry/]repository[:tag]'. The registry could be: - k8s.gcr.io - fictional.registry.example:10443 The repository could be: - kube-apiserver - fictional/nginx The tag cloud be: - latest - v1.19.1 - @sha256:dbcc1c35ac38df41fd2f5e4130b32ffdb93ebae8b3dbe638c23575912276fc9c
    pub component: EdgeApplicationWorkloadScopeTargetNodeGroupsOverridersImageOverridersComponent,
    /// Operator represents the operator which will apply on the image.
    pub operator: EdgeApplicationWorkloadScopeTargetNodeGroupsOverridersImageOverridersOperator,
    /// Predicate filters images before applying the rule. 
    ///  Defaults to nil, in that case, the system will automatically detect image fields if the resource type is Pod, ReplicaSet, Deployment or StatefulSet by following rule:   - Pod: /spec/containers/<N>/image   - ReplicaSet: /spec/template/spec/containers/<N>/image   - Deployment: /spec/template/spec/containers/<N>/image   - StatefulSet: /spec/template/spec/containers/<N>/image In addition, all images will be processed if the resource object has more than one containers. 
    ///  If not nil, only images matches the filters will be processed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub predicate: Option<EdgeApplicationWorkloadScopeTargetNodeGroupsOverridersImageOverridersPredicate>,
    /// Value to be applied to image. Must not be empty when operator is 'add' or 'replace'. Defaults to empty and ignored when operator is 'remove'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// ImageOverrider represents the rules dedicated to handling image overrides.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum EdgeApplicationWorkloadScopeTargetNodeGroupsOverridersImageOverridersComponent {
    Registry,
    Repository,
    Tag,
}

/// ImageOverrider represents the rules dedicated to handling image overrides.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum EdgeApplicationWorkloadScopeTargetNodeGroupsOverridersImageOverridersOperator {
    #[serde(rename = "add")]
    Add,
    #[serde(rename = "remove")]
    Remove,
    #[serde(rename = "replace")]
    Replace,
}

/// Predicate filters images before applying the rule. 
///  Defaults to nil, in that case, the system will automatically detect image fields if the resource type is Pod, ReplicaSet, Deployment or StatefulSet by following rule:   - Pod: /spec/containers/<N>/image   - ReplicaSet: /spec/template/spec/containers/<N>/image   - Deployment: /spec/template/spec/containers/<N>/image   - StatefulSet: /spec/template/spec/containers/<N>/image In addition, all images will be processed if the resource object has more than one containers. 
///  If not nil, only images matches the filters will be processed.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct EdgeApplicationWorkloadScopeTargetNodeGroupsOverridersImageOverridersPredicate {
    /// Path indicates the path of target field
    pub path: String,
}

/// WorkloadTemplate contains original templates of resources to be deployed as an EdgeApplication.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct EdgeApplicationWorkloadTemplate {
    /// Manifests represent a list of Kubernetes resources to be deployed on the managed node groups.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub manifests: Option<Vec<EdgeApplicationWorkloadTemplateManifests>>,
}

/// Status represents the status of PropagationStatus.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct EdgeApplicationStatus {
    /// WorkloadStatus contains running statuses of generated resources.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "workloadStatus")]
    pub workload_status: Option<Vec<EdgeApplicationStatusWorkloadStatus>>,
}

/// ManifestStatus contains running status of a specific manifest in spec.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct EdgeApplicationStatusWorkloadStatus {
    /// Conditions contain the different condition statuses for this manifest. Valid condition types are: 1. Processing: this workload is under processing and the current state of manifest does not match the desired. 2. Available: the current status of this workload matches the desired.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<EdgeApplicationStatusWorkloadStatusConditions>,
    /// Identifier represents the identity of a resource linking to manifests in spec.
    pub identifier: EdgeApplicationStatusWorkloadStatusIdentifier,
}

/// ManifestStatus contains running status of a specific manifest in spec.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum EdgeApplicationStatusWorkloadStatusConditions {
    Processing,
    Available,
}

/// Identifier represents the identity of a resource linking to manifests in spec.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct EdgeApplicationStatusWorkloadStatusIdentifier {
    /// Group is the group of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    /// Kind is the kind of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Name is the name of the resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace is the namespace of the resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Ordinal represents an index in manifests list, so the condition can still be linked to a manifest even though manifest cannot be parsed successfully.
    pub ordinal: i64,
    /// Resource is the resource type of the resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource: Option<String>,
    /// Version is the version of the resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

